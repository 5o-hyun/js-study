> 클로저는 **자바스크립트의 고유한 개념이아니라, 여러 함수형 프로그래밍 언어에서 공통적으로 발견되는 특성**이다.<br/>
> 그래서인지, 실제로 여러웹사이트에서 각기다른방식으로 클로저를 설명하는것을 살펴볼수있다.<br/>
> 때문에 '클로저' 개념을 습득할때, 순도 100%의 정확한 정의를 찾기보다는 다양한 사례를 살펴보고, 그것들을 토대로 이해하기쉬운 나만의 정의를 내려보는걸로 정하고 공부했다.


# 클로저
**함수와 그 함수가 선언된 렉시컬 환경과의 조합**이다.<br/>
내부함수가 정의될때 외부함수의 환경을 기억하고있는 내부함수를 말한다. 즉, **자신이 생성될때의 환경을 기억하는 함수**<br/>
**함수가 평가되는시점(실행x)에** 함수가 상위스코프의 렉시컬환경을 **참조**하게 되는것이다.

```
const makeCounter = () => {
  let count = 0; // 독립변수, 자유변수

  return () => {
    return count += 1;
  }
}

const counter = makeCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```
> 익명함수가 선언될때 익명함수의 내부슬롯에 makeCounter의 렉시컬환경을 참조한다.


1. const counter = makeCounter(); 에서 makeCounter함수가 호출될때 makeCounter함수의 컨텍스트가 생성된다.
2. makeCounter함수의 컨텍스트에 변수 count와 익명함수가 기록된다.
3. 익명함수가 기록될때 내부슬롯에 상위스코프의 렉시컬환경이 담긴다.
4. 익명함수가 상위스코프makeCounter의 렉시컬환경을 내부슬롯에 담아놨기때문에, 계속 참조를 안끊기고 하므로 가비지컬렉션의 대상이 되지않아 참조가 계속 살아있다.

이렇게 함수가 정의될때 자신의내부슬롯에 상위스코프의 렉시컬환경참조가 담기는것이다.<br/>
<br/>
여기서 변수 count는 독립변수, 자유변수이고 이것이 바로 클로저패턴을 쓰는이유다.<br/>
변수를 외부에서 접근할수없게하여 변수를은닉하고 독립적으로 쓰고싶을때 클로저패턴을 쓴다. ( 모듈화를 위함이라고도한다. )<br/>

<img src="https://velog.velcdn.com/images%2F5o_hyun%2Fpost%2F4a81985c-b4d7-4659-be21-b8c940c66299%2Fimage.png" />

# 클로저를 사용하는 이유 

1. 전역변수 사용억제
2. 현재상태를 기억하고 변경된 최신상태를 유지
3. 변수를 외부에서 접근할수없게하기위해서 = 정보은닉 

<br/><br/>
:fire: 다시 공부한 점

1. 클로저는 내부함수가 외부함수의 컨텍스트에 접근할수있는것을 가리킨다.
2. "외부로전달"이 항상 return을 의미하는건아니다.
3. 클로저는 특정상황에서 발생하는 "현상"이고 함수는 이 현상이 나타나기 위한 "조건"에 해당한다.
